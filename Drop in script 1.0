import random
import math
from copy import deepcopy
from dataclasses import dataclass
from collections import defaultdict
from typing import List, Dict, Tuple

# -----------------------------
# Original program constants
# -----------------------------
SEQUENCE_LENGTH = 3000
REGION_CHUNK = 50

ANCHORS = ["CTCF_TAG", "HISTONE_WRAP", "COHESIN_CLASP"]
ANCHOR_TIERS = [100, 200, 350]

RNA_TAGS = ["lncRNA_BRIDGE", "eRNA_NODE"]
RNA_SPACING = 180

PROTEINS = ["SMC_RING", "PHASE_HUB", "CHAPERONE"]
PROTEIN_SPACING = 250

MUTATION_BLOCK = "MUTATION_BLOCK"
MUTATION_SPACING = 300
MUTATION_SPAN = 30

STICKY_NODE = "STICKY_NODE"
STICKY_SPACING = 240
STICKY_SPAN = 15
STICKY_NEAR_ANCHOR_RANGE = 100

SSB_BOUNDARY = "SSB_BOUNDARY"
SSB_OFFSET = 1

FLEXIUM_WRAP = "FLEXIUM_WRAP"  # final firewall shield

ANCHOR_LOOP_REACH = 200
RNA_TO_ANCHOR_REACH = 60
NODE_NEARBY_REACH = 50

# -----------------------------
# Data structures
# -----------------------------
@dataclass
class Site:
    pos: int
    region: str  # "FLEX" or "RIGID"
    tags: List[str]

@dataclass
class Segment:
    kind: str   # "ANCHOR","RNA","PROTEIN","MUTATION","STICKY","SSB","FLEXIUM"
    label: str
    start: int
    end: int

# -----------------------------
# Sequence generation
# -----------------------------
def generate_sequence(length: int, chunk: int = REGION_CHUNK) -> List[Site]:
    seq: List[Site] = []
    toggle = True
    for i in range(length):
        region = "FLEX" if toggle else "RIGID"
        seq.append(Site(pos=i, region=region, tags=[]))
        if (i + 1) % chunk == 0:
            toggle = not toggle
    return seq

# -----------------------------
# Tag placement
# -----------------------------
def place_tiered_anchors(seq: List[Site], tiers: List[int]) -> List[Segment]:
    segs: List[Segment] = []
    for t in tiers:
        for pos in range(0, len(seq), t):
            tag = ANCHORS[(pos // t) % len(ANCHORS)]
            seq[pos].tags.append(tag)
            segs.append(Segment("ANCHOR", tag, pos, pos + 1))
    return segs

def place_rna_bridges(seq: List[Site], spacing: int = RNA_SPACING) -> List[Segment]:
    segs: List[Segment] = []
    for pos in range(0, len(seq), spacing):
        tag = RNA_TAGS[(pos // spacing) % len(RNA_TAGS)]
        end = min(pos + 30, len(seq))
        for j in range(pos, end):
            seq[j].tags.append(tag)
        segs.append(Segment("RNA", tag, pos, end))
    return segs

def place_protein_hubs(seq: List[Site], spacing: int = PROTEIN_SPACING) -> List[Segment]:
    segs: List[Segment] = []
    for pos in range(0, len(seq), spacing):
        tag = PROTEINS[(pos // spacing) % len(PROTEINS)]
        seq[pos].tags.append(tag)
        segs.append(Segment("PROTEIN", tag, pos, pos + 1))
    return segs

def place_mutation_blocks(seq: List[Site],
                          spacing: int = MUTATION_SPACING,
                          span: int = MUTATION_SPAN) -> List[Segment]:
    segs: List[Segment] = []
    for pos in range(0, len(seq), spacing):
        end = min(pos + span, len(seq))
        for j in range(pos, end):
            seq[j].tags.append(MUTATION_BLOCK)
        segs.append(Segment("MUTATION", MUTATION_BLOCK, pos, end))
    return segs

def find_anchor_positions(segs: List[Segment]) -> List[int]:
    return sorted([s.start for s in segs if s.kind == "ANCHOR"])

def place_minimal_sticky(seq: List[Site],
                         anchor_positions: List[int],
                         spacing: int = STICKY_SPACING,
                         span: int = STICKY_SPAN,
                         near_range: int = STICKY_NEAR_ANCHOR_RANGE) -> List[Segment]:
    segs: List[Segment] = []
    # Dual anchor zones (anchors within loop reach)
    duals = []
    for i in range(len(anchor_positions) - 1):
        a, b = anchor_positions[i], anchor_positions[i + 1]
        if b - a <= ANCHOR_LOOP_REACH:
            duals.append((a, b))

    # Thin film only near dual anchors
    for pos in range(0, len(seq), spacing):
        near_dual = any((a - near_range) <= pos <= (b + near_range) for a, b in duals)
        if not near_dual:
            continue
        end = min(pos + span, len(seq))
        for j in range(pos, end):
            # Never place sticky inside mutation blocks
            if MUTATION_BLOCK not in seq[j].tags:
                seq[j].tags.append(STICKY_NODE)
        segs.append(Segment("STICKY", STICKY_NODE, pos, end))
    return segs

def extend_ssb_boundaries(seq: List[Site],
                          sticky_segs: List[Segment],
                          offset: int = SSB_OFFSET) -> List[Segment]:
    ssb_segs: List[Segment] = []
    for s in sticky_segs:
        left = max(0, s.start - offset)
        right = min(len(seq), s.end + offset)
        if MUTATION_BLOCK not in seq[left].tags:
            seq[left].tags.append(SSB_BOUNDARY)
        if right - 1 < len(seq) and MUTATION_BLOCK not in seq[right - 1].tags:
            seq[right - 1].tags.append(SSB_BOUNDARY)
        ssb_segs.append(Segment("SSB", SSB_BOUNDARY, left, left + 1))
        ssb_segs.append(Segment("SSB", SSB_BOUNDARY, right - 1, right))
    return ssb_segs

def place_flexium_wrap(seq: List[Site]) -> List[Segment]:
    # Final firewall shielding across the whole sequence
    for s in seq:
        s.tags.append(FLEXIUM_WRAP)
    return [Segment("FLEXIUM", FLEXIUM_WRAP, 0, len(seq))]

# -----------------------------
# Graph construction
# -----------------------------
def build_graph(seq: List[Site], segs: List[Segment]) -> Dict[str, set]:
    graph: Dict[str, set] = defaultdict(set)
    def key_for(pos: int, label: str) -> str:
        return f"{label}@{pos}"

    anchors = [s for s in segs if s.kind == "ANCHOR"]
    rnas = [s for s in segs if s.kind == "RNA"]
    hubs = [s for s in segs if s.kind == "PROTEIN"]
    stickies = [s for s in segs if s.kind == "STICKY"]
    flexium = [s for s in segs if s.kind == "FLEXIUM"]

    # Connect nearby anchors (cohesin-like loops)
    anchors_sorted = sorted(anchors, key=lambda s: s.start)
    for i in range(len(anchors_sorted) - 1):
        a, b = anchors_sorted[i], anchors_sorted[i + 1]
        if b.start - a.start <= ANCHOR_LOOP_REACH:
            ka, kb = key_for(a.start, a.label), key_for(b.start, b.label)
            graph[ka].add(kb); graph[kb].add(ka)

    # RNA bridges to nearby anchors
    for r in rnas:
        kr = key_for(r.start, r.label)
        for a in anchors_sorted:
            if abs(a.start - r.start) <= RNA_TO_ANCHOR_REACH:
                ka = key_for(a.start, a.label)
                graph[kr].add(ka); graph[ka].add(kr)

    # Collect node positions for proximity wiring
    nodes_list = [(a.start, a.label) for a in anchors] + \
                 [(r.start, r.label) for r in rnas] + \
                 [(h.start, h.label) for h in hubs] + \
                 [(s.start, s.label) for s in stickies]
    nodes_list = sorted(list(set(nodes_list)), key=lambda x: x[0])

    # Protein hubs connect to nearest three nodes
    for h in hubs:
        kh = key_for(h.start, h.label)
        closest = sorted(nodes_list, key=lambda x: abs(x[0] - h.start))[:3]
        for pos, lbl in closest:
            kn = key_for(pos, lbl)
            if kn != kh:
                graph[kh].add(kn); graph[kn].add(kh)

    # Sticky nodes lightly connect within local reach
    for s in stickies:
        ks = key_for(s.start, s.label)
        for pos, lbl in nodes_list:
            if 0 < abs(pos - s.start) <= NODE_NEARBY_REACH:
                kn = key_for(pos, lbl)
                graph[ks].add(kn); graph[kn].add(ks)

    # Flexium wrap connects lightly to all known nodes (global shield)
    for f in flexium:
        kf = key_for(f.start, f.label)  # start=0 label=FLEXIUM_WRAP
        for pos, lbl in nodes_list:
            kn = key_for(pos, lbl)
            graph[kf].add(kn); graph[kn].add(kf)

    return graph

# -----------------------------
# Cohesion scoring
# -----------------------------
def cohesion_score(graph: Dict[str, set]) -> Tuple[float, Dict[str, float]]:
    nodes = list(graph.keys())
    edges = sum(len(v) for v in graph.values()) // 2

    visited = set()
    components: List[set] = []

    def dfs(u: str) -> set:
        stack = [u]
        comp = set()
        while stack:
            x = stack.pop()
            if x in comp:
                continue
            comp.add(x)
            for v in graph[x]:
                if v not in comp:
                    stack.append(v)
        return comp

    for n in nodes:
        if n not in visited:
            comp = dfs(n)
            visited |= comp
            components.append(comp)

    comp_sizes = [len(c) for c in components]
    largest = max(comp_sizes) if comp_sizes else 0
    avg_deg = (2 * edges / len(nodes)) if nodes else 0

    # Redundancy estimate: cycles ≈ edges - nodes + components
    cycles_est = max(0, edges - len(nodes) + len(components))

    # Balance penalty (avoid weak single giants or fragment sprawl)
    balance_penalty = 0.0
    if len(components) == 1 and avg_deg < 2.0:
        balance_penalty = 0.5
    if len(components) > 6:
        balance_penalty = 0.3

    score = 0.4 * largest + 0.4 * avg_deg + 0.2 * cycles_est
    score *= (1 - balance_penalty)
    stats = {
        "nodes": len(nodes),
        "edges": edges,
        "components": len(components),
        "largest_component": largest,
        "average_degree": round(avg_deg, 2),
        "redundancy": cycles_est,
    }
    return round(score, 2), stats

# -----------------------------
# Nanotech integrity model
# -----------------------------
DEFAULT_ENV = {"thermal": 0.25, "mechanical": 0.25, "chemical": 0.25, "radiation": 0.25}
BASE_FAIL_EDGE = 0.003   # baseline yearly bond failure
BASE_FAIL_NODE = 0.0005  # baseline yearly node failure
HUB_STRESS_REDUCTION = 0.35
EDGE_PASSIVATION_REDUCTION = 0.5
FLEXIUM_INITIAL = 0.6
FLEXIUM_DECAY = 0.004
RNA_REPAIR_PROB = 0.15
CASCADE_MULTIPLIER = 1.8

_state = {"t": 0, "env": DEFAULT_ENV.copy(), "flexium": FLEXIUM_INITIAL,
          "hub_reduction": HUB_STRESS_REDUCTION, "edge_passivation": EDGE_PASSIVATION_REDUCTION,
          "decay": FLEXIUM_DECAY, "shield_refresh_schedule": None}

def classify_node(key: str) -> str:
    label = key.split("@")[0]
    if label in ("CTCF_TAG", "HISTONE_WRAP", "COHESIN_CLASP"):
        return "ANCHOR"
    if label in ("SMC_RING", "PHASE_HUB", "CHAPERONE"):
        return "HUB"
    if label in ("lncRNA_BRIDGE", "eRNA_NODE"):
        return "RNA"
    if label == "STICKY_NODE":
        return "STICKY"
    if label == "SSB_BOUNDARY":
        return "SSB"
    if label == "FLEXIUM_WRAP":
        return "FLEXIUM"
    return "OTHER"

def effective_env() -> float:
    raw = sum(_state["env"].values())
    shield = max(0.0, _state["flexium"])
    return raw * (1.0 - shield)

def degree(graph, node):
    return len(graph.get(node, set()))

def neighbors(graph, node):
    return graph.get(node, set())

def is_edge_node(node):
    kind = classify_node(node)
    return kind in ("SSB", "STICKY")

def step_year(graph):
    to_remove_edges = []
    to_remove_nodes = set()

    # Optional shield refresh events
    if _state["shield_refresh_schedule"] and _state["t"] in _state["shield_refresh_schedule"]["years"]:
        # Connectivity check based on largest component proportion
        score, stats = cohesion_score(graph)
        nodes_count = stats["nodes"]
        largest = stats["largest_component"]
        if nodes_count > 0 and (largest / nodes_count) >= _state["shield_refresh_schedule"]["threshold"]:
            _state["flexium"] = min(0.95, _state["flexium"] + _state["shield_refresh_schedule"]["boost"])

    # Apply decay
    _state["flexium"] = max(0.0, _state["flexium"] - _state["decay"])

    # Precompute degrees
    deg = {n: degree(graph, n) for n in graph.keys()}

    env_load = effective_env()

    # Node failures
    for n in list(graph.keys()):
        kind = classify_node(n)
        k_mult = 1.0
        if kind == "ANCHOR": k_mult *= 0.6
        if kind == "HUB":    k_mult *= (1.0 - _state["hub_reduction"])
        if is_edge_node(n):  k_mult *= (1.0 - _state["edge_passivation"])
        p_node = BASE_FAIL_NODE * env_load * k_mult
        if deg.get(n,0) < 2:
            p_node *= CASCADE_MULTIPLIER
        if random.random() < p_node and classify_node(n) != "FLEXIUM":
            to_remove_nodes.add(n)

    # Edge failures with RNA repair
    visited_pairs = set()
    for u in list(graph.keys()):
        for v in list(graph[u]):
            pair = tuple(sorted((u, v)))
            if pair in visited_pairs:
                continue
            visited_pairs.add(pair)

            stress_mult = 1.0
            if classify_node(u) == "HUB" or classify_node(v) == "HUB":
                stress_mult *= (1.0 - _state["hub_reduction"])
            if is_edge_node(u) or is_edge_node(v):
                stress_mult *= (1.0 - _state["edge_passivation"])

            p_edge = BASE_FAIL_EDGE * env_load * stress_mult
            if deg.get(u,0) < 2 or deg.get(v,0) < 2:
                p_edge *= CASCADE_MULTIPLIER

            fail = random.random() < p_edge
            if fail:
                has_rna_neighbor = any(classify_node(x) == "RNA" for x in neighbors(graph, u) | neighbors(graph, v))
                if has_rna_neighbor and random.random() < RNA_REPAIR_PROB:
                    continue  # repaired
                to_remove_edges.append((u, v))

    # Apply removals
    for (u, v) in to_remove_edges:
        graph[u].discard(v)
        graph[v].discard(u)
    for n in to_remove_nodes:
        for m in list(graph.get(n, set())):
            graph[m].discard(n)
        graph.pop(n, None)

    _state["t"] += 1

def simulate_years(graph, years: int, seed: int) -> List[Tuple[float, Dict[str, float]]]:
    random.seed(seed)
    history = []
    for _ in range(years):
        step_year(graph)
        score, stats = cohesion_score(graph)
        stats["flexium_effectiveness"] = round(max(0.0, _state["flexium"]), 3)
        history.append((score, stats))
    return history

# -----------------------------
# Build base graph
# -----------------------------
def build_base_graph():
    seq = generate_sequence(SEQUENCE_LENGTH)

    segs_all: List[Segment] = []
    segs_all += place_tiered_anchors(seq, ANCHOR_TIERS)
    segs_all += place_rna_bridges(seq, spacing=RNA_SPACING)
    segs_all += place_protein_hubs(seq, spacing=PROTEIN_SPACING)
    segs_all += place_mutation_blocks(seq, spacing=MUTATION_SPACING, span=MUTATION_SPAN)

    anchor_positions = find_anchor_positions(segs_all)
    sticky_segs = place_minimal_sticky(
        seq,
        anchor_positions,
        spacing=STICKY_SPACING,
        span=STICKY_SPAN,
        near_range=STICKY_NEAR_ANCHOR_RANGE,
    )
    segs_all += sticky_segs

    ssb_segs = extend_ssb_boundaries(seq, sticky_segs, offset=SSB_OFFSET)
    segs_all += ssb_segs

    flexium_segs = place_flexium_wrap(seq)
    segs_all += flexium_segs

    graph = build_graph(seq, segs_all)
    return graph

# -----------------------------
# Verdict logic
# -----------------------------
def integrity_verdict(largest_component: int, nodes: int, avg_deg: float) -> str:
    # Thresholds tuned for clarity
    connectivity = (largest_component / nodes) if nodes else 0.0
    if connectivity >= 0.8 and avg_deg >= 2.0:
        return "GREEN"
    if connectivity >= 0.6 and avg_deg >= 1.5:
        return "YELLOW"
    return "RED"

def print_log_label(label: str):
    print("\n" + "="*72)
    print(f"{label}")
    print("="*72)

def print_yearly_log(year: int, score: float, stats: Dict[str, float]):
    print(f"Year {str(year).zfill(3)} | Score {score:6.2f} | "
          f"Largest {stats['largest_component']:4d}/{stats['nodes']:4d} | "
          f"AvgDeg {stats['average_degree']:4.2f} | Redund {stats['redundancy']:4d} | "
          f"Flexium {stats['flexium_effectiveness']:4.2f}")

def print_verdict(year: int, stats: Dict[str, float]):
    v = integrity_verdict(stats["largest_component"], stats["nodes"], stats["average_degree"])
    print(f"Verdict @ Year {year}: {v}")

# -----------------------------
# Scenario runners
# -----------------------------
def run_century(label: str, seed: int, env=None, decay=None,
                hub_reduction=None, edge_passivation=None,
                extra_hubs: bool=False, shield_refresh: Dict=None):
    # Build base
    base_graph = build_base_graph()

    # Optional: add extra hubs (approximation: connect additional hubs on spine)
    graph = deepcopy(base_graph)
    if extra_hubs:
        # Pick nodes roughly every 200 positions; connect them as extra hubs to nearest nodes
        candidates = [n for n in graph.keys() if n.startswith(("CTCF_TAG@", "HISTONE_WRAP@", "COHESIN_CLASP@"))]
        candidates = sorted(candidates, key=lambda k: int(k.split("@")[1]))
        for i in range(0, len(candidates), 200):
            k = candidates[i]
            # Create virtual hub node adjacent to this anchor
            hub_key = f"PHASE_HUB@extra{i}"
            # Connect to three nearest neighbors
            nearest = sorted(candidates, key=lambda c: abs(int(c.split("@")[1]) - int(k.split("@")[1])))[:3]
            for nn in nearest:
                graph[hub_key].add(nn); graph[nn].add(hub_key)

    # Reset state and parameters
    _state["t"] = 0
    _state["env"] = DEFAULT_ENV.copy() if env is None else env.copy()
    _state["flexium"] = FLEXIUM_INITIAL
    _state["hub_reduction"] = HUB_STRESS_REDUCTION if hub_reduction is None else hub_reduction
    _state["edge_passivation"] = EDGE_PASSIVATION_REDUCTION if edge_passivation is None else edge_passivation
    _state["decay"] = FLEXIUM_DECAY if decay is None else decay
    _state["shield_refresh_schedule"] = shield_refresh

    print_log_label(label)
    history = simulate_years(graph, years=100, seed=seed)

    # Compact yearly log
    for y, (score, stats) in enumerate(history, start=1):
        if y in (1, 10, 25, 50, 75, 100):  # sample log to avoid verbosity
            print_yearly_log(y, score, stats)

        if y in (25, 50, 75, 100):
            print_verdict(y, stats)

# -----------------------------
# Master run: all scenarios
# -----------------------------
def run_all_centuries():
    # Century-A: Baseline
    run_century(
        label="Century-A (Baseline)",
        seed=7
    )

    # Century-B: Harsh Environment
    harsh_env = {"thermal": 0.35, "mechanical": 0.25, "chemical": 0.25, "radiation": 0.35}
    run_century(
        label="Century-B (Harsh Environment)",
        seed=11,
        env=harsh_env,
        decay=0.006
    )

    # Century-C: Reinforced Hubs
    run_century(
        label="Century-C (Reinforced Hubs)",
        seed=13,
        hub_reduction=0.5,
        extra_hubs=True
    )

    # Century-D: Edge Unpassivated Control
    run_century(
        label="Century-D (Edge Unpassivated Control)",
        seed=19,
        edge_passivation=0.0
    )

    # Century-E: Shield Refresh Events
    shield_refresh = {"years": {25, 50, 75}, "boost": 0.10, "threshold": 0.80}
    run_century(
        label="Century-E (Shield Refresh Events)",
        seed=23,
        shield_refresh=shield_refresh
    )

if __name__ == "__main__":
    print("Lineage-safe synthetic plant (Heart-Shaped Herb analogue) — 100-year test suite")
    run_all_centuries()
